\documentclass[a4paper,10pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[french]{babel}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{textcomp}
\setlength{\textwidth}{16cm}
\setlength{\marginparwidth}{0cm}
\setlength{\oddsidemargin}{0cm}
\setlength{\headheight}{0cm}
\setlength{\topmargin}{0cm}
\setlength{\headsep}{0cm}
\setlength{\textheight}{25cm}
\setlength{\footskip}{0cm}
\setlength{\marginparsep}{0cm}
\lstset{basicstyle=\small\ttfamily,breaklines=true}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{textcomp}
\lstset{language=c++,basicstyle=\small\ttfamily,keywordstyle=\color{blue}\ttfamily,stringstyle=\color{red}\ttfamily,commentstyle=\color{green}\ttfamily,breaklines=true}


%opening
\title{Compte Rendu \\ NACHOS}
\author{BARTHELEMY Romain, EUDES Robin, MORISON Jack, ROSSI Ombeline}

\begin{document}
\maketitle
\tableofcontents
\newpage
\section{Introduction}
Ce projet a été réalisé dans le cadre de notre 4ème année d'étude à Polytech, avec la spécialisation ``systèmes et réseaux''.
En réalisant ce projet, nous avons put mettre en pratique l'ensemble des connaissances engrangés au cours de nos parcours et ainsi
comprendre les concepts entrant en jeu lors de la réalisation d'un système d'exploitation.
\vspace{0.5cm}

Dans un premier temps, nous allons nous intéresser
à la gestion de l'affichage de chaines de caractères de façon synchrone par le système. Nous allons également nous intéresser à la mise en place
d'un appel système (syscall). Par la suite, nous nous interesserons à la gestion des threads utilisateur, au multithreading.
\newpage
\section{Étape 2}
\subsection{Entrées-sorties asynchrones}
Une version élémentaire de gestion des entrées-sorties nous est fournie par NachOS, au travers de la classe \textit{Console}. Le code fournit
effectue une  gestion asynchrone des entrées-sorties. Nous devons donc gérer la synchronisation grâce à deux sémaphores ( pour gérer l'écriture et la lecture )
ainsi que deux handlers. Ceux-ci libèreront le sémaphore et nous informeront de la fin de l'opération de lecture/écriture. Ainsi, la synchronisation est assurée
par ce mécanisme.

Voici un extrait de code permetant cette gestion des entrées/sorties. Si le caractère est EOF, la machine s'arrête : syscall Halt() :
\begin{lstlisting}[frame=single]
void ConsoleTest (char *in, char *out){
    char ch;
    console = new Console (in, out, ReadAvail, WriteDone, 0);
    readAvail = new Semaphore ("read avail", 0);
    writeDone = new Semaphore ("write done", 0);

    for (;;) {
	  readAvail->P (); // wait for character to arrive
	  ch = console->GetChar ();
	  
	  #ifdef CHANGED
	  if(ch!='\n' && ch!=EOF){
		  console->PutChar ('<');
		  writeDone->P ();
	  }
	  #endif
	  
	  // Original code
	  #ifndef CHANGED 
	  console->PutChar (ch);
	  writeDone->P (); // wait for write to finish
	  if (ch == 'q')
		  return;
	  #else
	  
	  // Now, we prefer to exit on EOF,
	  // only if it's at the begin of a new line.
	  if(ch!=EOF){
		  console->PutChar (ch);
		  writeDone->P ();
		  if(ch!='\n'){
			  console->PutChar ('>');
			  writeDone->P ();
		  }
	  }
	  else{
		return;
	  }
	  if (ch=='\0'){ // EOT
		  return;
	  }
      #endif
      }
}
\end{lstlisting}
\newpage
\subsection{Entrées-sorties synchrones}
Nous devons maintenant créer une classe \textit{SynchConsole} afin de réaliser les opérations de synchronisation d'entrées/sorties automatiquement :
\begin{lstlisting}[frame=single]

static Semaphore *readAvail;
static Semaphore *writeDone;
static Semaphore *SemPutChar;
static Semaphore *SemGetChar;
static Semaphore *SemPutString;
static Semaphore *SemGetString;

static void ReadAvail(int arg) { readAvail->V(); }
static void WriteDone(int arg) { writeDone->V(); }

SynchConsole::SynchConsole(char *readFile, char *writeFile){
	readAvail = new Semaphore("read avail", 0);
	writeDone = new Semaphore("write done", 0);
	console = new Console (readFile, writeFile, ReadAvail, WriteDone, 0);

	SemPutChar = new Semaphore("PutChar", 1);
	SemGetChar = new Semaphore("GetChar", 1);
	SemPutString = new Semaphore("PutString", 1);
	SemGetString = new Semaphore("GetString", 1);
}

SynchConsole::~SynchConsole(){
	delete console;
	delete writeDone;
	delete readAvail;
}

void SynchConsole::SynchPutChar(const char ch){
	SemPutChar->P();
	console->PutChar (ch);
	writeDone->P ();
	SemPutChar->V();
}

char SynchConsole::SynchGetChar(){
	SemGetChar->P();
	char ch;
	readAvail->P ();
	ch = console->GetChar ();
	SemGetChar->V();
	return ch;
}
\end{lstlisting}
\newpage
Le test de ces méthodes est réalisé dans \textit{progtest.cc} par la fonction \textit{SynchConsoleTest}.
\begin{lstlisting}[frame=single]
 void SynchConsoleTest (char *in, char *out){
	char ch;
	SynchConsole *synchconsoletest = new SynchConsole(in, out);

	while ((ch = synchconsoletest->SynchGetChar()) != EOF){
		if(ch!='\n'){
			synchconsoletest->SynchPutChar('<');
			synchconsoletest->SynchPutChar(ch);
			synchconsoletest->SynchPutChar('>');
		}
		else{
			synchconsoletest->SynchPutChar(ch);
		}
	}
	fprintf(stderr, "Solaris: EOF detected in SynchConsole!\n");
}
\end{lstlisting}
\textit{Note : Chaque caractère est par ailleurs encadré par < >}

Le fichier \textit{main.cc} est modifié pour prendre en compte l'option -sc qui permetra l'éxecution
de la console synchrone. Initialement, la création de la console était effectuée dans \textit{system.cc , fonction Initilize}, mais suite à des erreurs
rencontrées dans les phases de test, l'instanciation de SynchConsole a été déplacée dans le main.
\begin{lstlisting}[frame=single]
#ifdef CHANGED
...
else if (!strcmp (*argv, "-sc")){
	if (argc == 1)
	    SynchConsoleTest (NULL, NULL);
	else
	  {
	      ASSERT (argc > 2);
	      SynchConsoleTest (*(argv + 1), *(argv + 2));
	      argCount = 3;
	  }
	interrupt->Halt ();
}
#endif // CHANGED
\end{lstlisting}
Deplus, la fonction \textit{Cleanup() , fichier exception.cc} est modifiée, pour suprimer cette nouvelle console lors de l'arrêt de la machine :
\begin{lstlisting}[frame=single]
...
#ifdef CHANGED
    delete synchconsole;
#endif //CHANGED
...
\end{lstlisting}
\newpage
\subsection{Création d'un syscall, Putchar}
Pour réaliser cet appel système, nous modifions \textit{syscall.h}, afin d'y ajouter putchar :
\begin{lstlisting}[frame=single]
 #define SC_PutChar		11
 ...
/* Print the character c on the terminal */
void PutChar(char c);
...
\end{lstlisting}
Le syscall est ensuite définit dans \textit{start.S} (en assembleur), en nous inspirant des syscall existants :
\begin{lstlisting}[frame=single]
	.globl PutChar
	.ent	PutChar
PutChar:
	addiu $2,$0,SC_PutChar
	syscall
	j	$31
	.end PutChar
\end{lstlisting}
Le syscall \textit{PutChar} défini, il nous reste à mettre en place de handler qui se chargera de la prise en compte
des exceptions relatives à PutChar ( fichier \textit{exception.cc, fonction ExceptionHandler} ) :

\begin{lstlisting}[frame=single]
if (which == SyscallException){
	switch(type){
		case SC_Halt:{
			DEBUG ('a', "Shutdown, initiated by user program.\n");
			interrupt->Halt ();
			break;
		}
		case SC_PutChar:{
			int c = machine->ReadRegister (4);
			synchconsole->SynchPutChar((char)c);
			break;
		}
		...
		default:{
			printf ("Unexpected user mode exception %d %d\n", which, type);
			ASSERT (FALSE);
		}
	}
}
\end{lstlisting}
\newpage
\subsection{La manipulation de chaine de caractères}
La manipulation des string nous permet d'étudier les spécificités de la simulation d'un système d'exploitation par NachOS.
En effet, nous devons jongler entre 2 espaces mémoire : l'espace MIPS (NachOS) et l'espace Linux.
\begin{lstlisting}[frame=single]
// Used for SynchPutString 
// get string from mips memory space , put it in linux memory space
void copyStringFromMachine( int from, char *to, unsigned size){
	unsigned int i;
	int tmp;
	for(i=0;i<size;i++){
		if(machine->ReadMem(from+i,1,&tmp))
		to[i]=tmp;
	}
	if(tmp!='\0'){
		to[size-1]='\0';
	}
}
// Used for SynchGetString
// get string from linux memory space, put it to mips memory space
void copyStringToMachine( char *from, int to, unsigned size){
	unsigned int i;
	int tmp;
	for(i=0;i<size-1;i++){
		tmp=from[i];
		machine->WriteMem(to+i,1,tmp);
	}
	tmp='\0';
	machine->WriteMem(to+i,1,tmp);
}
\end{lstlisting}

Nous devons ensuite ajouter les syscall associés SynchPutString et SynchGetString ( \textit{start.S } ) :
\begin{lstlisting}[frame=single]
//...
 SynchPutString:
	addiu $2,$0,SC_SynchPutString
	syscall
	j	$31
	.end SynchPutString

	.globl SynchGetChar
	.ent	SynchGetChar
//...
SynchGetString:
	addiu $2,$0,SC_SynchGetString
	syscall
	j	$31
	.end SynchGetString

	.globl SynchPutInt
	.ent	SynchPutInt
// ...
\end{lstlisting}
\newpage
Et mettre en place les Handler associés, comme pour les précédants appels système. ( fichier \textit{exception.cc , fonction ExceptionHandler} ) :
\begin{lstlisting}[frame=single]
 ...
case SC_SynchPutString:{
	char *buffer=new char[MAX_STRING_SIZE];
	int s = machine->ReadRegister (4);
	copyStringFromMachine(s, buffer, MAX_STRING_SIZE);
	synchconsole->SynchPutString(buffer);
	delete buffer;
	break;
}
...
case SC_SynchGetString:{
	char *buffer=new char[MAX_STRING_SIZE];
	int s = machine->ReadRegister (4);
	int size = machine->ReadRegister (5);
	synchconsole->SynchGetString(buffer,size);
	copyStringToMachine(buffer, s, size);
	delete buffer;
	break;
}
\end{lstlisting}
\textit{Note : MAX\_STRING\_SIZE , SC\_SynchPutString, SC\_SynchGetString sont définis dans system.h }
\newpage

Enfin, les fonctions SynchPutString et SynchGetString sont définies dans SynchConsole.cc :

\begin{lstlisting}[frame=single]
void SynchConsole::SynchPutString(const char s[]){
SemPutString->P();
int i;
for (i=0;i<MAX_STRING_SIZE && s[i]!='\0';i++){
	if (s[i]=='\0')
	return;
	synchconsole->SynchPutChar ((char)s[i]);
}
SemPutString->V();
}

void SynchConsole::SynchGetString(char *s, int n){
SemGetString->P();
char c;
int i;

c = synchconsole->SynchGetChar ();
if(c==EOF || c=='\n'){
	s[0]='\0';
	SemGetString->V();
	return;
}
else
	s[0] = c;
for (i=1;i<n;i++){
	c = synchconsole->SynchGetChar ();
	if(c==EOF && s[i-1]=='\n')
		break;
	else{
		if(c==EOF)
			i--;
		else
			s[i] = c;
	}
}
s[i]='\0';
SemGetString->V();
}
\end{lstlisting}
La méthode SynchGetString est un peu plus complexe que SynchPutString car nous devons maintenir un comportement :
Si EOF est vu en début de ligne, on termine la console, sinon ce dernier est ignoré (comme dans un système Linux).
\newpage
\section{Étape 3}
Dans un premier temps, nous nous intéresserons aux threads NachOS (mode kernel). Comment fonctionnent-ils ? Comment sont-ils initialisés ?
Nous allons observer le fonctionnement de progtest.cc , pour observer comment un programme utilisateur est chargé et exécuté par NachOS.
\subsection{Thread Nachos}
Les threads NachOS sont créés et initialisés dans la méthode \textit{Thread()} dans le fichier \textit{thread.cc}.
\begin{lstlisting}
 Thread::Thread (const char *threadName){
    name = threadName;
    stackTop = NULL;
    stack = NULL;
    status = JUST_CREATED;

#ifdef USER_PROGRAM
#ifdef CHANGED
    dependance=-1;
#endif //CHANGED

    space = NULL;

    for (int r=NumGPRegs; r<NumTotalRegs; r++)
      userRegisters[r] = 0;
#endif
}
\end{lstlisting}
La pile est initialisée. On positionne un entier ``dépendance'' à -1 (aucune dépendance vers un autre thread). Cette variable ajoutée nous sera utile par la suite,
pour ajouter une dépendance du thread courant vers un autre thread. Ensuite, l'espace mémoire du thread, ( code exécuté par le thread ) est pour l'instant NULL. Enfin,
les registres sont initialisés. À ce niveau, le thread a le status \textit{JUST\_CREATED}, il n'est pas encore prêt à être lancé ( status = \textit{READY} ).

Pour rendre ce thread exécutable, un appel à la méthode \textit{Fork} doit être effectué. Cette méthode prend en paramètre un pointeur vers le programme à charger en mémoire, et
les paramètres de la fonction (pointeur vers une structure contenant les arguments). L'espace mémoire du thread pointe vers celui thread courant, son status est mis à jour ( \textit{READY} ). Enfin, il est placé dans la ReadyQueue.

\newpage

Lors de la mise en place de l'espace d'adressage, le code qui sera exécuté par le thread est placé dans un objet \textit{NoffHeader}.

\begin{figure}[h]
  \begin{center}
    \includegraphics[scale=0.4]{./structnoff.png}
   \caption{\label{structnoff} Structure NoffHeader}
  \end{center}
\end{figure}

NoffMagic est un entier identifiant l'objet contenant le code à écuter comme étant de type NachOS.
La documentation nous apprend par ailleurs que le format d'object NachOS est une simplification du format d'oject UNIX.
Cet objet contient les segments code ( code exécutable ) et initdata (données initiales), ainsi qu'un segment ``uninitdata''.
Ces données sont contenues dans un espace d'adressage dont la taille maximale est de 4*1024 bits (StackSize défini dans \textit{thread.h}) .
\vspace{0.5cm}

Le système divise cet espace en pages, puis il effectue la correspondance des adresses physiques en adresses virtuelles.
Les données sont ensuite chargé en mémoire, en utilisant la table des pages. Ces dernières étapes sont réalisées dans le constructeur d'AddrSpace (fichier \textit{adrrspace.cc}).
À ce niveau, les pages virtuelles sont des pages physiques,
l'adressage virtuelle sera réalisé dans l'étape 4.

\vspace{0.5cm}

Les registres sont initialisés( PCReg, NextPCReg, StackReg, et les autres registres de NachOS).
Enfin, le programme est lancé, grâce à la méthode Run().




\subsection{Thread Utilisateur}

\end{document}
